import React, { useRef, useEffect } from 'react';
import * as d3 from 'd3';

export interface IScatterNode {
  text: string;
  x: number;
  y: number;
}

export interface IScatterPlotProps {
  data: IScatterNode[];
}

function ScatterPlot({ data }) {
  const svgRef = useRef(null);

  useEffect(() => {
    if (!svgRef.current) return;

    // D3 Code
    const svg = d3.select(svgRef.current);

    // Dimensions
    const { width } = svg.node().getBoundingClientRect();
    const { height } = svg.node().getBoundingClientRect();

    // Create Scales
    const xScale = d3
      .scaleLinear()
      .domain([d3.min(data, (d) => d.x), d3.max(data, (d) => d.x)])
      .range([0, width]);

    const yScale = d3
      .scaleLinear()
      .domain([d3.min(data, (d) => d.y), d3.max(data, (d) => d.y)])
      .range([height, 0]);

    // Clear previous SVG content
    svg.selectAll('*').remove();

    // Create Circles
    svg
      .selectAll('circle')
      .data(data)
      .enter()
      .append('circle')
      .attr('cx', (d) => xScale(d.x))
      .attr('cy', (d) => yScale(d.y))
      .attr('r', 5)
      .attr('fill', 'blue');

    // Create Lasso/Brush logic
    const brush = d3
      .brush()
      .extent([
        [0, 0],
        [width, height],
      ])
      .on('start brush end', (event) => {
        const { selection } = event;
        if (!selection) return;

        const [[x1, y1], [x2, y2]] = selection;

        svg.selectAll('circle').classed('selected', (d) => {
          return xScale(d.x) >= x1 && xScale(d.x) <= x2 && yScale(d.y) >= y1 && yScale(d.y) <= y2;
        });
      });

    // Append brush to SVG
    svg.append('g').attr('class', 'brush').call(brush);
  }, [data]);

  return (
    <svg ref={svgRef} style={{ width: '100%', height: '500px' }}>
      {/* Content generated by D3 */}
    </svg>
  );
}

export default ScatterPlot;
